# ------------------------------------------------------------------------------
# Project Euler - Problem 046 - Goldbach's other conjecture
# ------------------------------------------------------------------------------
# Problem Link: https://projecteuler.net/problem=046
# ------------------------------------------------------------------------------
# Author: Paul Frisby
# Email: mail@paulfrisby.com
# Github: https://github.com/paulfrisby/
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# Problem Definition
# ------------------------------------------------------------------------------
"""
It was proposed by Christian Goldbach that every odd composite number can be
written as the sum of a prime and twice a square.

9 = 7 + 2×1^2
15 = 7 + 2×2^2
21 = 3 + 2×3^2
25 = 7 + 2×3^2
27 = 19 + 2×2^2
33 = 31 + 2×1^2

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime
and twice a square?
"""
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# Pseudocode
# ------------------------------------------------------------------------------
"""
generate a list of primes using sieve of Eratosthenes

def GoldbachSum(n)
    for prime in primes[:n]:
        if squareroot((n - prime) / 2) is an integer:
            return true
    return false

for oddNum not in primes:
    if not GoldbachSum(oddNum):
        print oddNum
"""
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# Main Code
# ------------------------------------------------------------------------------

from math import sqrt

# returns a list where if n is a prime, list[n] = n, otherwise list[n] = 0
# uses sieve of Eratosthenes method to generate efficiently
def primeSieve(limit):

    # establishing list of integers up to, but not including limit
    primes = []
    for i in range(limit):
        primes.append(i)

    # as 1 is defined as not prime, setting this element of list to 0
    primes[1] = 0
    
    # setting all numbers divisible by 2 to 0 (excluding 2 itself) 
    prime = 2
    mult = 2
    while mult + 2 < limit:
        mult += 2
        primes[mult] = 0

    # removing multiples of odd primes    
    prime = 3
    while prime*prime < limit:

        # first multiple which needs to be removed is the square of prime
        # lesser multiples removed when multiples of lower primes sieved out
        # this is also why the p*p < limit evaluation is used for while loop
        mult = prime*prime

        # only odd multiples need to be removed, even numbers already sieved out
        # an even difference is applied to the mult so total value is still odd
        diff = 2*prime

        # setting value of every multiple of current prime to 0
        while mult < limit:
            primes[mult] = 0
            mult += diff

        # finding next prime in list, so that can be sieved out too    
        prime += 2
        while primes[prime] == 0:
            prime += 2
            
    return primes


def GoldbachSum(n):

    # only check for primes up to n, as larger primes prodcuse a sum too large
    for prime in primes[:n]:

        # where oddComposite = prime + 2s^2
        s = sqrt((n - prime) / 2)

        # if s is an integer,m the composite can be expressed in required form
        if s % 1 == 0:
            return True

    # no matches found
    return False



limit = 100000
found = False

while not found:
    primes = primeSieve(limit)
    for odd in range(9, len(primes), 2):

        # only check if the number is not prime, and thus is composite
        if primes[odd] == 0:
            if not GoldbachSum(odd):
                print (f'{odd} can not be written as the sum of a prime and twice a square')
                found = True
                break

    # if no answer found, increase amount of primes generated by 10, look again
    limit = limit * 10
